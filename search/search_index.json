{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Project Mu Project Mu is a modular adaptation of TianoCore's edk2 tuned for building modern devices using a scalable, maintainable, and reusable pattern. Mu is built around the idea that shipping and maintaining a UEFI product is an ongoing collaboration between numerous partners. For too long the industry has built products using a \"forking\" model combined with copy/paste/rename and with each new product the maintenace burden grows to such a level that updates are near impossible due to cost and risk. Project Mu also tries to address the complex business relationships and legal challenges facing partners today. To build most products it often requires both closed-source, proprietary assets as well as open source and industry standard code. The distributed build system and multi-repository design allows product teams to keep code separate and connected to their original source while respecting legal and business boundaries. Project Mu originated from building modern Windows PCs but its patterns and design allows it to be scaled down or up for whatever the final product's intent. IoT, Server, PC, or any other form factor should be able to leverage the content. Primary Goals Initially this project will focus on two central goals. \ud83d\udd39 Share our active code tree to both solicit feedback and entice partners to collaborate. Project Mu is an active project. This is not a side project, mirror, clone, or example. This is the same code used today on many of Microsoft's 1st party devices and it will be kept current because it must be to continue to enable shipping products. \ud83d\udd39 Promote, evangelize, and support an industry shift to a more collaborative environment so we all can build and maintain products with lower costs and higher quality. Today's open source projects although extremely valuable are very resource intensive to interact with. This friction leads to major industry players avoiding public interaction thus diminishing the overall community\u2019s value. The modern era of open source projects has incorporated new tools and procedures to lower this friction and it is our goal to leverage those tools. GitHub provides issue tracking, Pull Requests, Gated builds, tracked/required web-based code reviews, and CI/CD (Continuous builds and testing). It is our belief that by leveraging and extending this automation and workflow we can lower the friction and foster a safe place for all contributors to work. Guiding Principles Less is More * Be open to change / flexible - Keep learning. If it was easy this would have been solved before Design for code reuse Leverage tools / invest in automation Navigation Have a look around this site to see what is Project Mu. Start by reviewing details of the community and our process. See how to interact and get involved, why it's different, how to work within or extend it, as well as where everything is located. Next, dig thru the Usage Docs section to see how to use the project assets and finally explore the Developer Docs if you want to review APIs and individual modules. Having trouble? Skim the FAQ Roadmap Days Engaging with existing partners to collect feedback Pull Request documentation & gates Automated builds & compile tests of all repos Developer documentation on building & testing Determine communication venue (e.g. email list, Slack, Teams, ...), currently testing MS Teams Weeks Update to latest, stable EDK2 release Automated build & tests on a public platform Automated build & tests on Surface devices Add support for partner-requested compilers Feature documentation Draft process for security collaboration with partners & Tianocore Documentation on Governance Announce project & evangelize Months Containerized builds Join Us Contact info and additional methods to collaborate coming soon. Code of conduct This project has adopted the Microsoft Open Source Code of Conduct . For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments. Reporting Issues Short answer: Open a github issue. More details: Contributing Contributing Short answer: Open a pull request. More details: Contributing License Refer to License Version: 0.3 Build Time: 2018-09-28 19:42","title":"Home"},{"location":"#welcome-to-project-mu","text":"Project Mu is a modular adaptation of TianoCore's edk2 tuned for building modern devices using a scalable, maintainable, and reusable pattern. Mu is built around the idea that shipping and maintaining a UEFI product is an ongoing collaboration between numerous partners. For too long the industry has built products using a \"forking\" model combined with copy/paste/rename and with each new product the maintenace burden grows to such a level that updates are near impossible due to cost and risk. Project Mu also tries to address the complex business relationships and legal challenges facing partners today. To build most products it often requires both closed-source, proprietary assets as well as open source and industry standard code. The distributed build system and multi-repository design allows product teams to keep code separate and connected to their original source while respecting legal and business boundaries. Project Mu originated from building modern Windows PCs but its patterns and design allows it to be scaled down or up for whatever the final product's intent. IoT, Server, PC, or any other form factor should be able to leverage the content.","title":"Welcome to Project Mu"},{"location":"#primary-goals","text":"Initially this project will focus on two central goals.","title":"Primary Goals"},{"location":"#share-our-active-code-tree-to-both-solicit-feedback-and-entice-partners-to-collaborate","text":"Project Mu is an active project. This is not a side project, mirror, clone, or example. This is the same code used today on many of Microsoft's 1st party devices and it will be kept current because it must be to continue to enable shipping products.","title":"&#x1F539; Share our active code tree to both solicit feedback and entice partners to collaborate."},{"location":"#promote-evangelize-and-support-an-industry-shift-to-a-more-collaborative-environment-so-we-all-can-build-and-maintain-products-with-lower-costs-and-higher-quality","text":"Today's open source projects although extremely valuable are very resource intensive to interact with. This friction leads to major industry players avoiding public interaction thus diminishing the overall community\u2019s value. The modern era of open source projects has incorporated new tools and procedures to lower this friction and it is our goal to leverage those tools. GitHub provides issue tracking, Pull Requests, Gated builds, tracked/required web-based code reviews, and CI/CD (Continuous builds and testing). It is our belief that by leveraging and extending this automation and workflow we can lower the friction and foster a safe place for all contributors to work.","title":"&#x1F539; Promote, evangelize, and support an industry shift to a more collaborative environment so we all can build and maintain products with lower costs and higher quality."},{"location":"#guiding-principles","text":"Less is More * Be open to change / flexible - Keep learning. If it was easy this would have been solved before Design for code reuse Leverage tools / invest in automation","title":"Guiding Principles"},{"location":"#navigation","text":"Have a look around this site to see what is Project Mu. Start by reviewing details of the community and our process. See how to interact and get involved, why it's different, how to work within or extend it, as well as where everything is located. Next, dig thru the Usage Docs section to see how to use the project assets and finally explore the Developer Docs if you want to review APIs and individual modules.","title":"Navigation"},{"location":"#having-trouble","text":"Skim the FAQ","title":"Having trouble?"},{"location":"#roadmap","text":"","title":"Roadmap"},{"location":"#days","text":"Engaging with existing partners to collect feedback Pull Request documentation & gates Automated builds & compile tests of all repos Developer documentation on building & testing Determine communication venue (e.g. email list, Slack, Teams, ...), currently testing MS Teams","title":"Days"},{"location":"#weeks","text":"Update to latest, stable EDK2 release Automated build & tests on a public platform Automated build & tests on Surface devices Add support for partner-requested compilers Feature documentation Draft process for security collaboration with partners & Tianocore Documentation on Governance Announce project & evangelize","title":"Weeks"},{"location":"#months","text":"Containerized builds","title":"Months"},{"location":"#join-us","text":"Contact info and additional methods to collaborate coming soon.","title":"Join Us"},{"location":"#code-of-conduct","text":"This project has adopted the Microsoft Open Source Code of Conduct . For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments.","title":"Code of conduct"},{"location":"#reporting-issues","text":"Short answer: Open a github issue. More details: Contributing","title":"Reporting Issues"},{"location":"#contributing","text":"Short answer: Open a pull request. More details: Contributing","title":"Contributing"},{"location":"#license","text":"Refer to License Version: 0.3 Build Time: 2018-09-28 19:42","title":"License"},{"location":"faq/","text":"Purpose/Goals How is this related to TianoCore? As you can probably tell, Project Mu is based on TianoCore . It represents a variant of TianoCore that was customized within Microsoft for scaling and maintainability. It's not exactly a staging branch for TianoCore, as there are some changes that may not have application within or meet the explicit goals of that project, but it is a place where features and changes can be publicly featured and discussed. So, is this a fork? Not entirely. It is our goal to continue to treat TianoCore as a true upstream. Our release branches will always be based on the latest stable TianoCore release, and we will always try to PR viable fixes and features into the TianoCore project. What is it? Where is it going? Project Mu is a product of the Microsoft Core UEFI team and is the basis for the system firmware within a number of Microsoft products. It will continue to be maintained to reflect the FW practices and features leveraged for the best experience with Windows and other Microsoft products. A secondary purpose is to engage with the community, both in TianoCore and the industry at large. We hope that Project Mu serves as a concrete example for discussing different approaches to managing the challenges faced by the UEFI ecosystem. Is this really following \"Less is More\"? Yes. The idea is lowering the entanglement of code, lowering the coupling, and allowing the product to pick and choose the code it needs. This means when building any given product, you don't need all the Project Mu code. Why are there so many repos? Project Mu makes liberal use of multiple repositories due to the mixture of requirements in the UEFI ecosystem. Some repos are split for technical reasons, some for organizational, and some for legal. For details, see \"Repo Philosophy\" in What and Why .","title":"FAQ"},{"location":"faq/#purposegoals","text":"","title":"Purpose/Goals"},{"location":"faq/#how-is-this-related-to-tianocore","text":"As you can probably tell, Project Mu is based on TianoCore . It represents a variant of TianoCore that was customized within Microsoft for scaling and maintainability. It's not exactly a staging branch for TianoCore, as there are some changes that may not have application within or meet the explicit goals of that project, but it is a place where features and changes can be publicly featured and discussed.","title":"How is this related to TianoCore?"},{"location":"faq/#so-is-this-a-fork","text":"Not entirely. It is our goal to continue to treat TianoCore as a true upstream. Our release branches will always be based on the latest stable TianoCore release, and we will always try to PR viable fixes and features into the TianoCore project.","title":"So, is this a fork?"},{"location":"faq/#what-is-it-where-is-it-going","text":"Project Mu is a product of the Microsoft Core UEFI team and is the basis for the system firmware within a number of Microsoft products. It will continue to be maintained to reflect the FW practices and features leveraged for the best experience with Windows and other Microsoft products. A secondary purpose is to engage with the community, both in TianoCore and the industry at large. We hope that Project Mu serves as a concrete example for discussing different approaches to managing the challenges faced by the UEFI ecosystem.","title":"What is it? Where is it going?"},{"location":"faq/#is-this-really-following-less-is-more","text":"Yes. The idea is lowering the entanglement of code, lowering the coupling, and allowing the product to pick and choose the code it needs. This means when building any given product, you don't need all the Project Mu code.","title":"Is this really following \"Less is More\"?"},{"location":"faq/#why-are-there-so-many-repos","text":"Project Mu makes liberal use of multiple repositories due to the mixture of requirements in the UEFI ecosystem. Some repos are split for technical reasons, some for organizational, and some for legal. For details, see \"Repo Philosophy\" in What and Why .","title":"Why are there so many repos?"},{"location":"license/","text":"Licensing for Project Mu Project Mu has numerous repositories. Each of these can have a different licenses depending on the content and partner but in general we want OSS friendly licenses. For this documentation we use the following license. License BSD 2-Clause License Copyright (c) Microsoft All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"License"},{"location":"license/#licensing-for-project-mu","text":"Project Mu has numerous repositories. Each of these can have a different licenses depending on the content and partner but in general we want OSS friendly licenses. For this documentation we use the following license.","title":"Licensing for Project Mu"},{"location":"license/#license","text":"BSD 2-Clause License Copyright (c) Microsoft All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"License"},{"location":"DeveloperDocs/developerdocs/","text":"Developer Docs This section of the docs will contain API and low level details directly pulled from the source of code modules. This should be auto generated from markdown files scattered throughout the Project Mu code tree. Details Coming Soon!","title":"Docs"},{"location":"DeveloperDocs/developerdocs/#developer-docs","text":"This section of the docs will contain API and low level details directly pulled from the source of code modules. This should be auto generated from markdown files scattered throughout the Project Mu code tree.","title":"Developer Docs"},{"location":"DeveloperDocs/developerdocs/#details-coming-soon","text":"","title":"Details Coming Soon!"},{"location":"How/contributing/","text":"How to contribute There are three common ways to contribute. Participate in discussions using GitHub issues. Contribute code by opening a GitHub Pull Request Contribute documentation by opening a GitHub Pull Request. Contributor License Agreement (CLA) This project welcomes contributions and suggestions. Most (code and documentation) contributions require you to agree to a Contributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us the rights to use your contribution. For details, visit https://cla.microsoft.com. When you submit a pull request, a CLA-bot will automatically determine whether you need to provide a CLA and decorate the PR appropriately (e.g., label, comment). Simply follow the instructions provided by the bot. You will only need to do this once across all repos using our CLA. General feedback and discussions? Please start a discussion on the Project Mu repo issue tracker . Bugs and feature requests? For non-security related bugs please log a new issue on the Project Mu repo issue tracker . Reporting security issues and bugs Security issues and bugs should be reported privately, via email, to the Microsoft Security Response Center (MSRC) secure@microsoft.com. You should receive a response within 24 hours. If for some reason you do not, please follow up via email to ensure we received your original message. Further information, including the MSRC PGP key, can be found in the Security TechCenter . Filing issues Please start a discussion on the Project Mu repo issue tracker . The best way to get your bug fixed is to be as detailed as you can be about the problem. Providing a minimal project with steps to reproduce the problem is ideal. GitHub supports markdown , so when filing bugs make sure you check the formatting before clicking submit. Contributing code and documentation Process documentation coming soon Obtaining the source code Building our Repositories Submitting a pull request If you don't know what a pull request is read this article: https://help.github.com/articles/using-pull-requests . Make sure the respository can build and all tests pass. Familiarize yourself with the project workflow and our coding conventions. Commit/Pull Request Format Tests Tests need to be provided for every bug/feature that is completed.","title":"Contributing"},{"location":"How/contributing/#how-to-contribute","text":"There are three common ways to contribute. Participate in discussions using GitHub issues. Contribute code by opening a GitHub Pull Request Contribute documentation by opening a GitHub Pull Request.","title":"How to contribute"},{"location":"How/contributing/#contributor-license-agreement-cla","text":"This project welcomes contributions and suggestions. Most (code and documentation) contributions require you to agree to a Contributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us the rights to use your contribution. For details, visit https://cla.microsoft.com. When you submit a pull request, a CLA-bot will automatically determine whether you need to provide a CLA and decorate the PR appropriately (e.g., label, comment). Simply follow the instructions provided by the bot. You will only need to do this once across all repos using our CLA.","title":"Contributor License Agreement (CLA)"},{"location":"How/contributing/#general-feedback-and-discussions","text":"Please start a discussion on the Project Mu repo issue tracker .","title":"General feedback and discussions?"},{"location":"How/contributing/#bugs-and-feature-requests","text":"For non-security related bugs please log a new issue on the Project Mu repo issue tracker .","title":"Bugs and feature requests?"},{"location":"How/contributing/#reporting-security-issues-and-bugs","text":"Security issues and bugs should be reported privately, via email, to the Microsoft Security Response Center (MSRC) secure@microsoft.com. You should receive a response within 24 hours. If for some reason you do not, please follow up via email to ensure we received your original message. Further information, including the MSRC PGP key, can be found in the Security TechCenter .","title":"Reporting security issues and bugs"},{"location":"How/contributing/#filing-issues","text":"Please start a discussion on the Project Mu repo issue tracker . The best way to get your bug fixed is to be as detailed as you can be about the problem. Providing a minimal project with steps to reproduce the problem is ideal. GitHub supports markdown , so when filing bugs make sure you check the formatting before clicking submit.","title":"Filing issues"},{"location":"How/contributing/#contributing-code-and-documentation","text":"Process documentation coming soon","title":"Contributing code and documentation"},{"location":"How/contributing/#obtaining-the-source-code","text":"","title":"Obtaining the source code"},{"location":"How/contributing/#building-our-repositories","text":"","title":"Building our Repositories"},{"location":"How/contributing/#submitting-a-pull-request","text":"If you don't know what a pull request is read this article: https://help.github.com/articles/using-pull-requests . Make sure the respository can build and all tests pass. Familiarize yourself with the project workflow and our coding conventions.","title":"Submitting a pull request"},{"location":"How/contributing/#commitpull-request-format","text":"","title":"Commit/Pull Request Format"},{"location":"How/contributing/#tests","text":"Tests need to be provided for every bug/feature that is completed.","title":"Tests"},{"location":"How/downstream_integration/","text":"Downstream Project Integration Describe successful patterns for integrating downstream for Common, Silicon, and Platform layers. Describe impacts of rebase process Describe how to report back integration status and errors (automation)","title":"Downstream Integration"},{"location":"How/downstream_integration/#downstream-project-integration","text":"Describe successful patterns for integrating downstream for Common, Silicon, and Platform layers. Describe impacts of rebase process Describe how to report back integration status and errors (automation)","title":"Downstream Project Integration"},{"location":"How/release_process/","text":"Overview","title":"Release Process"},{"location":"How/release_process/#overview","text":"","title":"Overview"},{"location":"How/upstream_integration/","text":"Upsteam Integration Tianocore integration","title":"Upstream Integration"},{"location":"How/upstream_integration/#upsteam-integration","text":"","title":"Upsteam Integration"},{"location":"How/upstream_integration/#tianocore-integration","text":"","title":"Tianocore integration"},{"location":"UsageDocs/usagedocs/","text":"Usage Docs This section of the docs will contain usage information for a developer using Project Mu. Details on compiling or testing code, gathering performance data, debug logs, or using features of the code modules will be documented here. This should be auto generated from markdown files scattered throughout the Project Mu code tree. Details Coming Soon!","title":"Docs"},{"location":"UsageDocs/usagedocs/#usage-docs","text":"This section of the docs will contain usage information for a developer using Project Mu. Details on compiling or testing code, gathering performance data, debug logs, or using features of the code modules will be documented here. This should be auto generated from markdown files scattered throughout the Project Mu code tree.","title":"Usage Docs"},{"location":"UsageDocs/usagedocs/#details-coming-soon","text":"","title":"Details Coming Soon!"},{"location":"WhatAndWhy/componentization/","text":"Packages / Dependencies TBD","title":"Componentization"},{"location":"WhatAndWhy/componentization/#packages-dependencies","text":"TBD","title":"Packages / Dependencies"},{"location":"WhatAndWhy/layers/","text":"Conceptual Layers Today there are lots of types and sources of UEFI code in a full featured product. Some examples: TianoCore EDK2 UEFI standard based code TianoCore additional value add code Silicon Vendor code Silicon Vendor supplied value add code Independent BIOS Vendor code ODM/OEM Value add code OS firmware support code Legacy BIOS compatibility code Platform Code Board specific code * etc. Then there are open source versions and closed source version. There are overrides and bug fixes implemented by everyone across the stack. Then there is bleeding edge vs last year's version (or maybe 2 years ago). It's no wonder that everyone does it differently. Compound the version and source problem with the sheer size. A common UEFI code base is generally well above 1 million LOC and only goes up from there. Clearly there is a lot of problems that can stem from this. Project Mu is an attempt to bring some sanity to the issue by creating a rigid layering concept and aligning our partners. Layering won't fix everything but it's a start. What is a dependency To understand the layering you must first understand the terminology. There are two types of code assets. A definition of something. Generally, this is defined in an accessible header file. This is the API provided by some asset. This API can be \"depended\" on to provide some capability. A implementation of something. Generally this is A dependency is code that relies on a definition or prototype","title":"Layering"},{"location":"WhatAndWhy/layers/#conceptual-layers","text":"Today there are lots of types and sources of UEFI code in a full featured product. Some examples: TianoCore EDK2 UEFI standard based code TianoCore additional value add code Silicon Vendor code Silicon Vendor supplied value add code Independent BIOS Vendor code ODM/OEM Value add code OS firmware support code Legacy BIOS compatibility code Platform Code Board specific code * etc. Then there are open source versions and closed source version. There are overrides and bug fixes implemented by everyone across the stack. Then there is bleeding edge vs last year's version (or maybe 2 years ago). It's no wonder that everyone does it differently. Compound the version and source problem with the sheer size. A common UEFI code base is generally well above 1 million LOC and only goes up from there. Clearly there is a lot of problems that can stem from this. Project Mu is an attempt to bring some sanity to the issue by creating a rigid layering concept and aligning our partners. Layering won't fix everything but it's a start.","title":"Conceptual Layers"},{"location":"WhatAndWhy/layers/#what-is-a-dependency","text":"To understand the layering you must first understand the terminology. There are two types of code assets. A definition of something. Generally, this is defined in an accessible header file. This is the API provided by some asset. This API can be \"depended\" on to provide some capability. A implementation of something. Generally this is A dependency is code that relies on a definition or prototype","title":"What is a dependency"},{"location":"WhatAndWhy/layout/","text":"Block Diagram File Layout To best preserve and delineate these concepts of componentization and unidirectional dependency, we have chosen to lay out our repository files in a structure that reinforces the same mentality. The underlying logic of this layout is to clearly distinguish each layer from the rest. As such, the Basecore -- which is considered foundational -- is broken out on its own, followed by the Common repos, followed by the Silicon, followed by the Platform. As mentioned elsewhere, Project Mu makes liberal use of multiple repositories due to the mixture of requirements in the firmware ecosystem. Some repos are split for technical reasons, some for organizational, and some for legal. One of the goals of Project Mu is to make this seemingly complicated layout easier to work with. Add graphics and more details...","title":"Layout"},{"location":"WhatAndWhy/layout/#block-diagram","text":"","title":"Block Diagram"},{"location":"WhatAndWhy/layout/#file-layout","text":"To best preserve and delineate these concepts of componentization and unidirectional dependency, we have chosen to lay out our repository files in a structure that reinforces the same mentality. The underlying logic of this layout is to clearly distinguish each layer from the rest. As such, the Basecore -- which is considered foundational -- is broken out on its own, followed by the Common repos, followed by the Silicon, followed by the Platform. As mentioned elsewhere, Project Mu makes liberal use of multiple repositories due to the mixture of requirements in the firmware ecosystem. Some repos are split for technical reasons, some for organizational, and some for legal. One of the goals of Project Mu is to make this seemingly complicated layout easier to work with. Add graphics and more details...","title":"File Layout"},{"location":"WhatAndWhy/overview/","text":"Project Organization This documentation is hosted in the main repository for Project Mu, which is used as a central collection point for community interaction and documentation. The build system and firmware code for the project is hosted in a number of other repositories, grouped/divided by function, partner, license, and dependencies. Several of these repositories are brought together by the build system to create a FW project, but we'll get into those details later. ;) For now, an overview of the repositories and what code you'll find there... Mu Basecore This repository is considered foundational and fundamental to Project Mu. The guiding philosophy is that this code should be one or more of the following: Part of the build system Common to any silicon architecture Part of the \"API layer\" that contains protocol and library definitions including * Industry Standards * UEFI Specifications * ACPI Specifications Part of the \"PI\" layer that contains driver dispatch logic, event/signaling logic, or memory management logic * This can also include central technologies like variable services Mu Common Plus The packages found in this repository are contributed entirely by Project Mu. They should be common to all silicon architectures and only depend on Mu Basecore. These packages provide features and functionality that are entirely optional, but may be recommended for PC platform FW. Mu Tiano Plus This repository contains only modules that were originally sourced from TianoCore. They are not essential for any particular platform, but are likely useful to many platforms. The versions contained in this repo are modified and/or improved to work with the rest of Project Mu. Repo Philosophy Project Mu makes liberal use of multiple repositories due to the mixture of requirements in the UEFI ecosystem. Some repos are split for technical reasons, some for organizational, and some for legal. Examples of this are: A downstream contributor wants to add a generic feature with a silicon-specific implementation. This feature would be leveraged by Common code. If all code were in one repository, no barries would be in place to prevent the contributor from directly calling from Common code into the Silicon implementation. By forcing the API/interface to be published in a separate repository, we can ensure that the unidirectional dependency relationship is maintained. Module A and Module B both provide optional functionality. However, Module A is far more likely to be consume by a wide audience than Module B. To achieve \"Less is More\", Module A may be placed in a different repos to enable downstream consumers to carry as little \"unused\" code as possible, since it's likely they would not need Module B in their code tree. A downstream consumer is producing a product in conjunction with a vendor/partner. While most of the enabling code for the vendor component is open-source, a portion of it is only released under NDA. By having multiple repositories comprise a single workspace, the downstream consumer is able to maximize their open-source consumption (which minimizes forking) while maintaining the legal requirements of closed-source/proprietary partitioning.","title":"Overview"},{"location":"WhatAndWhy/overview/#project-organization","text":"This documentation is hosted in the main repository for Project Mu, which is used as a central collection point for community interaction and documentation. The build system and firmware code for the project is hosted in a number of other repositories, grouped/divided by function, partner, license, and dependencies. Several of these repositories are brought together by the build system to create a FW project, but we'll get into those details later. ;) For now, an overview of the repositories and what code you'll find there...","title":"Project Organization"},{"location":"WhatAndWhy/overview/#mu-basecore","text":"This repository is considered foundational and fundamental to Project Mu. The guiding philosophy is that this code should be one or more of the following: Part of the build system Common to any silicon architecture Part of the \"API layer\" that contains protocol and library definitions including * Industry Standards * UEFI Specifications * ACPI Specifications Part of the \"PI\" layer that contains driver dispatch logic, event/signaling logic, or memory management logic * This can also include central technologies like variable services","title":"Mu Basecore"},{"location":"WhatAndWhy/overview/#mu-common-plus","text":"The packages found in this repository are contributed entirely by Project Mu. They should be common to all silicon architectures and only depend on Mu Basecore. These packages provide features and functionality that are entirely optional, but may be recommended for PC platform FW.","title":"Mu Common Plus"},{"location":"WhatAndWhy/overview/#mu-tiano-plus","text":"This repository contains only modules that were originally sourced from TianoCore. They are not essential for any particular platform, but are likely useful to many platforms. The versions contained in this repo are modified and/or improved to work with the rest of Project Mu.","title":"Mu Tiano Plus"},{"location":"WhatAndWhy/overview/#repo-philosophy","text":"Project Mu makes liberal use of multiple repositories due to the mixture of requirements in the UEFI ecosystem. Some repos are split for technical reasons, some for organizational, and some for legal. Examples of this are: A downstream contributor wants to add a generic feature with a silicon-specific implementation. This feature would be leveraged by Common code. If all code were in one repository, no barries would be in place to prevent the contributor from directly calling from Common code into the Silicon implementation. By forcing the API/interface to be published in a separate repository, we can ensure that the unidirectional dependency relationship is maintained. Module A and Module B both provide optional functionality. However, Module A is far more likely to be consume by a wide audience than Module B. To achieve \"Less is More\", Module A may be placed in a different repos to enable downstream consumers to carry as little \"unused\" code as possible, since it's likely they would not need Module B in their code tree. A downstream consumer is producing a product in conjunction with a vendor/partner. While most of the enabling code for the vendor component is open-source, a portion of it is only released under NDA. By having multiple repositories comprise a single workspace, the downstream consumer is able to maximize their open-source consumption (which minimizes forking) while maintaining the legal requirements of closed-source/proprietary partitioning.","title":"Repo Philosophy"},{"location":"Where/external_resources/","text":"External Resources UEFI Industry Organization UEFI is the industry standards body that develops and distributes the UEFI, PI, and ACPI specifications. These specifications govern the firmware interfaces between OS, OEM/Device Manufacturer, and Silicon partner. This is a great site to download the industry specifications and if you are a member you can join working groups for future specifications. TianoCore Project Tianocore is an existing open source project. Their EDK2 repository is the basis for many/most UEFI implementations used on products today. It provides UEFI spec compliant code modules, supports industry standard hardware, and a multiplatform build environment. This is a great site to download specifications for the different file types and build process. It also has links to repositories that Project Mu tracks as \"upstreams\". MkDocs Great tool for creating documentation websites based on markdown. In fact it was used to generate this documentation. Markdown Help Quick link for common markdown support.","title":"External Resources"},{"location":"Where/external_resources/#external-resources","text":"","title":"External Resources"},{"location":"Where/external_resources/#uefi-industry-organization","text":"UEFI is the industry standards body that develops and distributes the UEFI, PI, and ACPI specifications. These specifications govern the firmware interfaces between OS, OEM/Device Manufacturer, and Silicon partner. This is a great site to download the industry specifications and if you are a member you can join working groups for future specifications.","title":"UEFI Industry Organization"},{"location":"Where/external_resources/#tianocore-project","text":"Tianocore is an existing open source project. Their EDK2 repository is the basis for many/most UEFI implementations used on products today. It provides UEFI spec compliant code modules, supports industry standard hardware, and a multiplatform build environment. This is a great site to download specifications for the different file types and build process. It also has links to repositories that Project Mu tracks as \"upstreams\".","title":"TianoCore Project"},{"location":"Where/external_resources/#mkdocs","text":"Great tool for creating documentation websites based on markdown. In fact it was used to generate this documentation.","title":"MkDocs"},{"location":"Where/external_resources/#markdown-help","text":"Quick link for common markdown support.","title":"Markdown Help"},{"location":"Where/project_resources/","text":"Public Source Code Repositories https://github.com/Microsoft/mu_basecore https://github.com/Microsoft/mu_tiano_plus https://github.com/Microsoft/mu_plus Issue/Bug/Feature Tracking https://github.com/Microsoft/mu/issues Builds Coming soon! Docs https://microsoft.github.io/mu/ Help For now the best path is to open an Issue with the \"question\" tag https://github.com/Microsoft/mu/issues","title":"Project Resources"},{"location":"Where/project_resources/#public-source-code-repositories","text":"https://github.com/Microsoft/mu_basecore https://github.com/Microsoft/mu_tiano_plus https://github.com/Microsoft/mu_plus","title":"Public Source Code Repositories"},{"location":"Where/project_resources/#issuebugfeature-tracking","text":"https://github.com/Microsoft/mu/issues","title":"Issue/Bug/Feature Tracking"},{"location":"Where/project_resources/#builds","text":"Coming soon!","title":"Builds"},{"location":"Where/project_resources/#docs","text":"https://microsoft.github.io/mu/","title":"Docs"},{"location":"Where/project_resources/#help","text":"For now the best path is to open an Issue with the \"question\" tag https://github.com/Microsoft/mu/issues","title":"Help"}]}